{
    "common": {
        "cleared": "CLEARED",
        "locked": "LOCKED",
        "unlocked": "UNLOCKED",
        "levels": "{count} levels",
        "done": "✓ DONE",
        "initializing": "Initializing...",
        "back_to_stages": "Back to Stage Select",
        "back_to_stages_short": "← STAGES",
        "reset": "RESET",
        "run_verify": "RUN & VERIFY",
        "intel_syntax": "INTEL SYNTAX",
        "att_syntax": "AT&T SYNTAX",
        "editor": "EDITOR",
        "registers": "REGISTERS",
        "io_stream": "I/O STREAM",
        "exception": "EXCEPTION:",
        "unknown_stage": "UNKNOWN STAGE",
        "unknown_stage_title": "Unknown Grand Stage",
        "unknown_stage_desc": "The specified grand stage could not be found.",
        "stage_not_implemented": "The level definitions for this grand stage have not yet been implemented in the app.",
        "missing_id": "Unimplemented ID: ",
        "lang_ja": "日本語",
        "lang_en": "English"
    },
    "top": {
        "brand_sub": "Grand Stage Select",
        "hint": "Grand stages are unlocked sequentially. To proceed to the next grand stage, please clear all levels in the previous one.",
        "free_editor": "Free x86-64 Editor"
    },
    "explanation": {
        "close": "Close Explanation",
        "read": "Read Explanation",
        "close_solution": "Close Solution",
        "view_solution": "View Solution",
        "loading": "Loading explanation...",
        "error": "Failed to load explanation: {error}",
        "loading_solution": "Loading solution...",
        "error_solution": "Failed to load model answer: {error}",
        "solution_title": "Model Answer (collect.asm)"
    },
    "status": {
        "ready": "READY",
        "executing": "EXECUTING...",
        "validating": "Validating logic against test vectors...",
        "success": "SUCCESS",
        "failed": "FAILED",
        "mission_accomplished": "Mission accomplished. Level cleared.",
        "runtime_error": "RUNTIME ERROR",
        "system_error": "SYSTEM ERROR",
        "select_level": "Please select a level from the list on the left before running.",
        "select_to_begin": "Select a level to begin the mission."
    },
    "grand_stages": {
        "1": {
            "title": "The Accumulator",
            "description": "A comprehensive review of the basics of registers/ALU, flags, jumps, and loops."
        },
        "2": {
            "title": "The Stack",
            "description": "Master the concepts of saving, reordering, and stack calculations centered around push/pop."
        }
    },
    "levels": {
        "01_Mov&Call": {
            "name": "Mov & Call",
            "description": "Read bytes from stdin (syscall 0), write them to stdout (syscall 1)."
        },
        "02_Addition": {
            "name": "Addition",
            "description": "Read bytes, add 1 to each byte, write result."
        },
        "03_Subtraction": {
            "name": "Subtraction",
            "description": "Read bytes, subtract 1 from each byte, write result."
        },
        "04_TheXORTrick": {
            "name": "The XOR Trick",
            "description": "Read bytes, XOR each byte with 0x20, write result."
        },
        "05_Inc&Dec": {
            "name": "Inc & Dec",
            "description": "Read bytes. Inc even-indexed bytes, dec odd-indexed bytes, write result."
        },
        "06_Unconditional": {
            "name": "Unconditional",
            "description": "Same as stage 01, but use JMP to structure the control flow."
        },
        "07_ZeroFlag": {
            "name": "Zero Flag",
            "description": "Read bytes, replace 0x00 with 0x20 (space), write result."
        },
        "08_SignFlag": {
            "name": "Sign Flag",
            "description": "Read bytes, output '+' if first byte is non-negative, otherwise '-'."
        },
        "09_Comparison": {
            "name": "Comparison",
            "description": "Read bytes, compare consecutive bytes, output '+', '=', '-' markers (length N-1)."
        },
        "10_Countdown": {
            "name": "Countdown",
            "description": "Read one ASCII digit, output a countdown from it to '0'."
        },
        "11_Accumulate3": {
            "name": "Accumulate 3",
            "description": "Read bytes, sum the first 3 bytes (u8), output 1 byte result."
        },
        "12_TheAccumulator": {
            "name": "The Accumulator (BOSS)",
            "description": "Read bytes and transform: A-Z -> a-z, 0-9 -> increment (wrap 9->0), others unchanged."
        },
        "13_Push&Pop": {
            "name": "Push & Pop",
            "description": "Read A, push/pop it, then output A (1 byte)."
        },
        "14_SwapTwo": {
            "name": "Swap Two",
            "description": "Read A,B and output B,A (2 bytes)."
        },
        "15_Duplicate": {
            "name": "Duplicate",
            "description": "Read A and output A,A (2 bytes)."
        },
        "16_Reverse3": {
            "name": "Reverse 3",
            "description": "Read A,B,C and output C,B,A (3 bytes)."
        },
        "17_ReverseUntil0": {
            "name": "Reverse Until 0",
            "description": "Read values until 0, output them reversed (0 not included)."
        },
        "18_SumFromStack": {
            "name": "Sum From Stack",
            "description": "Read values until 0, sum them, output 1 byte result."
        },
        "19_SafePop": {
            "name": "Safe Pop",
            "description": "Process tokens (push/pop) without underflow; output final depth."
        },
        "20_RPN_AddOnly": {
            "name": "RPN (Add Only)",
            "description": "RPN evaluation: numbers push, -1 add, 0 end; output top."
        },
        "21_Sort3": {
            "name": "Sort 3",
            "description": "Read 3 values and output them sorted ascending (3 bytes)."
        },
        "22_Rotate3": {
            "name": "Rotate 3",
            "description": "Read A,B,C and output B,C,A (3 bytes)."
        },
        "23_MinMaxFromStack": {
            "name": "Min & Max From Stack",
            "description": "Read values until 0; output min then max (2 bytes)."
        },
        "24_TheStackMachine": {
            "name": "The Stack Machine (BOSS)",
            "description": "Token machine: +push, -1 add, -2 sub, -3 xor, 0 end; output top."
        }
    },
    "tutorial": {
        "courses": {
            "basics": {
                "title": "Architecture Basics",
                "description": "Learn the basics of CPU, registers, the MOV instruction, and system calls."
            }
        },
        "sections": {
            "intro": {
                "title": "Assembly and Registers",
                "slides": {
                    "s1": {
                        "title": "Welcome to the World of Assembly",
                        "content": "Assembly language is the language closest to the **machine code** that computers can directly understand.\nFor example, the instruction `mov rax, 42` tells the CPU: \"Put the value 42 into the location called rax\"."
                    },
                    "s2": {
                        "title": "The CPU's \"Boxes\": Registers",
                        "content": "Inside the CPU, there are high-speed storage locations called **registers**.\nIn the x86-64 architecture, we use 64-bit registers with names like `rax`, `rbx`, `rcx`, and `rdx`."
                    },
                    "s3": {
                        "title": "Moving Data: The MOV Instruction",
                        "content": "The **MOV** instruction is used to copy data.\n\n`mov rax, 100`  ; Copy 100 into rax\n`mov rbx, rax`  ; Copy content of rax into rbx\n\nIn assembly, anything after a `;` is treated as a comment."
                    },
                    "s4": {
                        "title": "Requesting the OS: SYSCALL",
                        "content": "To ask the OS for things like printing to the screen or exiting, we use the **syscall** instruction.\nYou put the \"request type (syscall number)\" into `rax`, and \"details\" into registers like `rdi`.\n\nExample: Exiting the program\n`mov rax, 60`  ; 60 is exit\n`mov rdi, 0`   ; Exit code 0\n`syscall`      ; Execute!"
                    }
                },
                "exercise": {
                    "title": "Set a Value and Exit",
                    "description": "Set the syscall number `60` in `rax`, set `0` in `rdi`, and execute `syscall`.",
                    "instruction": "Enter the following code into the editor:\n`mov rax, 60`\n`mov rdi, 0`\n`syscall`"
                }
            },
            "io": {
                "title": "Basic Input & Output",
                "slides": {
                    "s1": {
                        "title": "Talking to the World: I/O",
                        "content": "Programs don't just calculate. They interact with the outside world by reading from **stdin** and writing to **stdout**."
                    },
                    "s2": {
                        "title": "Reading Magic: Syscall 0",
                        "content": "To read data, we use **syscall 0 (read)**.\n\n`mov rax, 0`   ; syscall number 0 (read)\n`mov rdi, 0`   ; file descriptor 0 (stdin)\n`mov rsi, buf` ; buffer address\n`mov rdx, 1`   ; bytes to read\n`syscall`"
                    },
                    "s3": {
                        "title": "Writing Magic: Syscall 1",
                        "content": "To write data, we use **syscall 1 (write)**.\n\n`mov rax, 1`   ; syscall number 1 (write)\n`mov rdi, 1`   ; file descriptor 1 (stdout)\n`mov rsi, buf` ; buffer address\n`mov rdx, 1`   ; bytes to write\n`syscall`"
                    }
                },
                "exercise": {
                    "title": "Echo Program",
                    "description": "Let's read data and write it back exactly as is (Echo).",
                    "instruction": "1. Read 1 byte using `syscall 0`.\n2. Write that byte using `syscall 1`.\n3. Exit using `syscall 60`."
                }
            },
            "registers": {
                "title": "Calculations and Arithmetic",
                "slides": {
                    "s1": {
                        "title": "Let's Add: The ADD Instruction",
                        "content": "The **ADD** instruction is used to add two values together.\n\n`add rax, 5`  ; Add 5 to rax\n\nThe result is stored in the left-hand register (rax in this case)."
                    },
                    "s2": {
                        "title": "Let's Subtract: The SUB Instruction",
                        "content": "The **SUB** instruction is used to subtract a value.\n\n`sub rbx, 10`  ; Subtract 10 from rbx\n\nJust like ADD, the result is saved back into the left-hand register."
                    }
                },
                "exercise": {
                    "title": "Try Some Math",
                    "description": "Create a program that reads input, adds 1, and writes the result.",
                    "instruction": "1. Read 1 byte using `syscall 0`.\n2. Add 1 to the value using the `add` instruction.\n3. Write the result using `syscall 1`.\n\nRepeat this process twice (for two inputs)."
                }
            }
        },
        "common": {
            "next": "Next",
            "back": "Back",
            "start_exercise": "Start Exercise",
            "back_to_slides": "Back to Slides",
            "mission": "MISSION",
            "instruction": "INSTRUCTION",
            "course_list": "Course List",
            "home": "Home",
            "level_cleared": "Level Cleared!",
            "next_section": "Next Section",
            "stay_here": "Stay Here"
        }
    }
}